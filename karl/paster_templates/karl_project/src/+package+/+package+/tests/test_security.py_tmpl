import unittest
from repoze.bfg import testing

class ConformsToISecurityWorkflow:

    def test_class_conforms_to_ISecurityWorkflow(self):
        from zope.interface.verify import verifyClass
        from karl.security.interfaces import ISecurityWorkflow
        verifyClass(ISecurityWorkflow, self._getTargetClass())

    def test_instance_conforms_to_ISecurityWorkflow(self):
        from zope.interface.verify import verifyObject
        from karl.security.interfaces import ISecurityWorkflow
        verifyObject(ISecurityWorkflow, self._makeOne())

class CommunityTransitionsTests(unittest.TestCase):
    def _getTargetClass(self):
        from {{package}}.security import CommunityTransitions
        return CommunityTransitions

    def _makeOne(self):
        return self._getTargetClass()()

    def test_to_private(self):
        from zope.interface import directlyProvides
        from repoze.bfg.security import Allow
        from karl.models.interfaces import ICommunity
        from karl.security.policy import ADMINISTRATOR_PERMS
        from karl.security.policy import MEMBER_PERMS
        from karl.security.policy import MODERATOR_PERMS
        from karl.security.policy import NO_INHERIT
        ob = testing.DummyModel()
        ob.__acl__ = ['1']
        index = DummyIndex()
        ob.catalog = {'path': index}
        ob.docid = 1234
        directlyProvides(ob, ICommunity)
        ob.moderators_group_name = 'moderators'
        ob.members_group_name = 'members'
        transitions = self._makeOne()
        transitions.to_private('from', 'to', 'yup', ob)
        self.assertEqual(ob.__acl__[0],
                         (Allow, 'group.KarlAdmin', ADMINISTRATOR_PERMS))
        self.assertEqual(ob.__acl__[1], (Allow, 'moderators', MODERATOR_PERMS))
        self.assertEqual(ob.__acl__[2], (Allow, 'members', MEMBER_PERMS))
        self.assertEqual(ob.__acl__[3], NO_INHERIT)
        self.assertEqual(index.indexed, {1234: ob})

    def test_to_public(self):
        from zope.interface import directlyProvides
        from repoze.bfg.security import Allow
        from karl.models.interfaces import ICommunity
        from karl.security.policy import ADMINISTRATOR_PERMS
        from karl.security.policy import GUEST_PERMS
        from karl.security.policy import MEMBER_PERMS
        from karl.security.policy import MODERATOR_PERMS
        from karl.security.policy import NO_INHERIT
        ob = testing.DummyModel()
        ob.__acl__ = ['1']
        index = DummyIndex()
        ob.catalog = {'path': index}
        ob.docid = 1234
        directlyProvides(ob, ICommunity)
        ob.moderators_group_name = 'moderators'
        ob.members_group_name = 'members'
        transitions = self._makeOne()
        transitions.to_public('from', 'to', 'yup', ob)
        self.assertEqual(ob.__acl__[0],
                         (Allow, 'group.KarlAdmin', ADMINISTRATOR_PERMS))
        self.assertEqual(ob.__acl__[1], (Allow, 'moderators', MODERATOR_PERMS))
        self.assertEqual(ob.__acl__[2], (Allow, 'members', MEMBER_PERMS))
        self.assertEqual(ob.__acl__[3], NO_INHERIT)
        self.assertEqual(index.indexed, {1234: ob})

    def test_do_nothing(self):
        # dead chicken for coverage
        ob = testing.DummyModel()
        transitions = self._makeOne()
        transitions.do_nothing('bogus', 'nonesuch', 'worthless', ob)


class CommunityWorkflowTests(unittest.TestCase, ConformsToISecurityWorkflow):

    def _getTargetClass(self):
        from {{package}}.security import CommunityWorkflow
        return CommunityWorkflow

    def _makeOne(self, context=None):
        if context is None:
            context = testing.DummyModel()
        return self._getTargetClass()(context)

    def _makeContext(self):
        from zope.interface import directlyProvides
        from karl.models.interfaces import ICommunity
        context = testing.DummyModel()
        directlyProvides(context, ICommunity)
        context.moderators_group_name = 'moderators'
        context.members_group_name = 'members'
        index = DummyIndex()
        context.catalog = {'path': index}
        context.docid = 1234
        return context

    def test_setInitialState_defaults(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        workflow.setInitialState()
        self.assertEqual(context.security_state, 'public')

    def test_setInitialState_sharing_False(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        workflow.setInitialState(sharing='false')
        self.assertEqual(context.security_state, 'public')

    def test_setInitialState_sharing_True(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        workflow.setInitialState(sharing='true')
        self.assertEqual(context.security_state, 'private')

    def test_updateState_private_sharing_True_noop(self):
        context = self._makeContext()
        context.security_state = 'private'
        workflow = self._makeOne(context)
        workflow.updateState(sharing='true')
        self.assertEqual(context.security_state, 'private')

    def test_updateState_private_sharing_False_does_transition(self):
        context = self._makeContext()
        context.security_state = 'private'
        workflow = self._makeOne(context)
        workflow.updateState(sharing='false')
        self.assertEqual(context.security_state, 'public')

    def test_updateState_public_sharing_True_does_transition(self):
        context = self._makeContext()
        context.security_state = 'public'
        workflow = self._makeOne(context)
        workflow.updateState(sharing='true')
        self.assertEqual(context.security_state, 'private')

    def test_updateState_public_sharing_False_noop(self):
        context = self._makeContext()
        context.security_state = 'public'
        workflow = self._makeOne(context)
        workflow.updateState(sharing='false')
        self.assertEqual(context.security_state, 'public')

    def test_execute_private_to_private(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        context.security_state = 'private'
        workflow.execute('private')
        self.assertEqual(context.security_state, 'private')

    def test_execute_initial_to_private(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        context.security_state = 'initial'
        workflow.execute('private')
        self.assertEqual(context.security_state, 'private')

    def test_execute_public_to_public(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        context.security_state = 'public'
        workflow.execute('public')
        self.assertEqual(context.security_state, 'public')

    def test_execute_initial_to_public(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        context.security_state = 'initial'
        workflow.execute('public')
        self.assertEqual(context.security_state, 'public')

    def test_execute_private_to_public(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        context.security_state = 'private'
        workflow.execute('public')
        self.assertEqual(context.security_state, 'public')

class CommunityContentTransitionsTests(unittest.TestCase):
    def _getTargetClass(self):
        from {{package}}.security import CommunityContentTransitions
        return CommunityContentTransitions

    def _makeOne(self):
        return self._getTargetClass()()

    def test_to_inherits_has_no_acl(self):
        ob = testing.DummyModel()
        index = DummyIndex()
        ob.catalog = {'path': index}
        ob.docid = 1234
        transitions = self._makeOne()
        transitions.to_inherits('from', 'to', 'yup', ob)
        # doesn't blow up
        self.failIf(hasattr(ob, '__acl__'))
        # don't reindex because already in correct state.
        self.assertEqual(index.indexed, {})

    def test_to_inherits_has_acl(self):
        ob = testing.DummyModel()
        ob.__acl__ = ['1']
        index = DummyIndex()
        ob.catalog = {'path': index}
        ob.docid = 1234
        transitions = self._makeOne()
        transitions.to_inherits('from', 'to', 'yup', ob)
        self.failIf(hasattr(ob, '__acl__'))
        self.assertEqual(index.indexed, {1234: ob})

    def test_to_private(self):
        from karl.models.interfaces import ICommunity
        ob = testing.DummyModel()
        ob.__acl__ = ['1']
        index = DummyIndex()
        ob.catalog = {'path': index}
        ob.docid = 1234
        from zope.interface import directlyProvides
        directlyProvides(ob, ICommunity)
        ob.moderators_group_name = 'moderators'
        ob.members_group_name = 'members'
        transitions = self._makeOne()
        transitions.to_private('from', 'to', 'yup', ob)
        from repoze.bfg.security import Allow
        from karl.security.policy import MODERATOR_PERMS
        from karl.security.policy import MEMBER_PERMS
        from karl.security.policy import NO_INHERIT
        self.assertEqual(ob.__acl__[0], (Allow, 'moderators', MODERATOR_PERMS))
        self.assertEqual(ob.__acl__[1], (Allow, 'members', MEMBER_PERMS))
        self.assertEqual(ob.__acl__[2], NO_INHERIT)
        self.assertEqual(index.indexed, {1234: ob})

    def test_to_public(self):
        from karl.models.interfaces import ICommunity
        from karl.models.interfaces import ISite
        ob = testing.DummyModel()
        ob.__acl__ = ['1']
        index = DummyIndex()
        ob.docid = 1234
        ob.catalog = {'path': index}
        from zope.interface import directlyProvides
        from zope.interface import alsoProvides
        directlyProvides(ob, ICommunity)
        alsoProvides(ob, ISite)
        ob.staff_acl = ['a'] # ignored
        ob.moderators_group_name = 'moderators'
        ob.members_group_name = 'members'
        transitions = self._makeOne()
        transitions.to_public('from', 'to', 'yup', ob)
        from repoze.bfg.security import Allow
        from karl.security.policy import MODERATOR_PERMS
        from karl.security.policy import MEMBER_PERMS
        from karl.security.policy import NO_INHERIT
        self.assertEqual(ob.__acl__[0], (Allow, 'moderators', MODERATOR_PERMS))
        self.assertEqual(ob.__acl__[1], (Allow, 'members', MEMBER_PERMS))
        self.assertEqual(ob.__acl__[2], NO_INHERIT)
        self.assertEqual(index.indexed, {1234: ob})

    def test_do_nothing(self):
        # dead chicken for coverage
        ob = testing.DummyModel()
        transitions = self._makeOne()
        transitions.do_nothing('bogus', 'nonesuch', 'worthless', ob)


class CommunityContentWorkflowTests(unittest.TestCase,
                                    ConformsToISecurityWorkflow):

    def _getTargetClass(self):
        from {{package}}.security import CommunityContentWorkflow
        return CommunityContentWorkflow

    def _makeOne(self, context=None):
        if context is None:
            context = testing.DummyModel()
        return self._getTargetClass()(context)

    def _makeContext(self):
        from zope.interface import directlyProvides
        from karl.models.interfaces import ICommunity
        community = testing.DummyModel()
        directlyProvides(community, ICommunity)
        index = DummyIndex()
        community.catalog = {'path': index}
        community.moderators_group_name = 'group.moderators'
        community.members_group_name = 'group.members'
        context = testing.DummyModel()
        context.__parent__ = community
        context.creator = 'testing'
        context.docid = 1234
        return context

    def test_setInitialState_defaults(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        workflow.setInitialState()
        self.assertEqual(context.security_state, 'inherits')

    def test_setInitialState_sharing_False(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        workflow.setInitialState(sharing='false')
        self.assertEqual(context.security_state, 'public')

    def test_setInitialState_sharing_True(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        workflow.setInitialState(sharing='true')
        self.assertEqual(context.security_state, 'private')

    def test_updateState_private_sharing_True_noop(self):
        context = self._makeContext()
        context.security_state = 'private'
        workflow = self._makeOne(context)
        workflow.updateState(sharing='true')
        self.assertEqual(context.security_state, 'private')

    def test_updateState_private_sharing_False_does_transition(self):
        context = self._makeContext()
        context.security_state = 'private'
        workflow = self._makeOne(context)
        workflow.updateState(sharing='false')
        self.assertEqual(context.security_state, 'public')

    def test_updateState_public_sharing_True_does_transition(self):
        context = self._makeContext()
        context.security_state = 'public'
        workflow = self._makeOne(context)
        workflow.updateState(sharing='true')
        self.assertEqual(context.security_state, 'private')

    def test_updateState_public_sharing_False_noop(self):
        context = self._makeContext()
        context.security_state = 'public'
        workflow = self._makeOne(context)
        workflow.updateState(sharing='false')
        self.assertEqual(context.security_state, 'public')

    def test_execute_inherits_to_inherits(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        context.security_state = 'inherits'
        workflow.execute('inherits')
        self.assertEqual(context.security_state, 'inherits')

    def test_execute_private_to_private(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        context.security_state = 'private'
        workflow.execute('private')
        self.assertEqual(context.security_state, 'private')

    def test_execute_public_to_public(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        context.security_state = 'public'
        workflow.execute('public')
        self.assertEqual(context.security_state, 'public')

class BlogentryTransitionsTests(unittest.TestCase):
    def _getTargetClass(self):
        from {{package}}.security import BlogentryTransitions
        return BlogentryTransitions

    def _makeOne(self):
        return self._getTargetClass()()

    def test_to_inherits_has_no_acl(self):
        from repoze.bfg.security import Allow
        from repoze.bfg.security import Deny
        from repoze.bfg.security import Everyone
        from karl.security.policy import MEMBER_PERMS
        ob = testing.DummyModel()
        ob.docid = 1234
        ob.creator = 'dummyUser'
        index = DummyIndex()
        ob.catalog = {'path': index}
        transitions = self._makeOne()

        transitions.to_inherits('from', 'to', 'yup', ob)

        acl = ob.__acl__
        self.assertEqual(len(acl), 2)
        self.assertEqual(acl[0], (Allow, 'dummyUser', MEMBER_PERMS))
        self.assertEqual(acl[1], (Deny, Everyone, ('edit', 'delete')))

        self.assertEqual(index.indexed, {1234: ob})

    def test_to_inherits_has_acl(self):
        from repoze.bfg.security import Allow
        from repoze.bfg.security import Deny
        from repoze.bfg.security import Everyone
        from karl.security.policy import MEMBER_PERMS
        ob = testing.DummyModel()
        ob.docid = 1234
        ob.creator = 'dummyUser'
        ob.__acl__ = ['1']
        index = DummyIndex()
        ob.catalog = {'path': index}
        transitions = self._makeOne()

        transitions.to_inherits('from', 'to', 'yup', ob)

        acl = ob.__acl__
        self.assertEqual(len(acl), 2)
        self.assertEqual(acl[0], (Allow, 'dummyUser', MEMBER_PERMS))
        self.assertEqual(acl[1], (Deny, Everyone, ('edit', 'delete')))

        self.assertEqual(index.indexed, {1234: ob})


class BlogentryWorkflowTests(unittest.TestCase, ConformsToISecurityWorkflow):

    def _getTargetClass(self):
        from {{package}}.security import BlogentryWorkflow
        return BlogentryWorkflow

    def _makeOne(self, context=None):
        if context is None:
            context = testing.DummyModel()
        return self._getTargetClass()(context)

    def _makeContext(self):
        from zope.interface import directlyProvides
        from karl.models.interfaces import ICommunity
        community = testing.DummyModel()
        directlyProvides(community, ICommunity)
        index = DummyIndex()
        community.catalog = {'path': index}
        community.moderators_group_name = 'group.moderators'
        community.members_group_name = 'group.members'
        context = testing.DummyModel()
        context.__parent__ = community
        context.creator = 'testing'
        context.docid = 1234
        return context

    def test_setInitialState_defaults(self):
        context = self._makeContext()
        context.creator = 'testing'
        workflow = self._makeOne(context)
        workflow.setInitialState()
        self.assertEqual(context.security_state, 'inherits')

    def test_setInitialState_sharing_False(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        workflow.setInitialState(sharing='false')
        self.assertEqual(context.security_state, 'public')

    def test_setInitialState_sharing_True(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        workflow.setInitialState(sharing='true')
        self.assertEqual(context.security_state, 'private')

    def test_updateState_private_sharing_True_noop(self):
        context = self._makeContext()
        context.security_state = 'private'
        workflow = self._makeOne(context)
        workflow.updateState(sharing='true')
        self.assertEqual(context.security_state, 'private')

    def test_updateState_private_sharing_False_does_transition(self):
        context = self._makeContext()
        context.security_state = 'private'
        workflow = self._makeOne(context)
        workflow.updateState(sharing='false')
        self.assertEqual(context.security_state, 'public')

    def test_updateState_public_sharing_True_does_transition(self):
        context = self._makeContext()
        context.security_state = 'public'
        workflow = self._makeOne(context)
        workflow.updateState(sharing='true')
        self.assertEqual(context.security_state, 'private')

    def test_updateState_public_sharing_False_noop(self):
        context = self._makeContext()
        context.security_state = 'public'
        workflow = self._makeOne(context)
        workflow.updateState(sharing='false')
        self.assertEqual(context.security_state, 'public')

    def test_execute_inherits_to_inherits(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        context.security_state = 'inherits'
        workflow.execute('inherits')
        self.assertEqual(context.security_state, 'inherits')

    def test_execute_private_to_private(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        context.security_state = 'private'
        workflow.execute('private')
        self.assertEqual(context.security_state, 'private')

    def test_execute_public_to_public(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        context.security_state = 'public'
        workflow.execute('public')
        self.assertEqual(context.security_state, 'public')


class ProfileWorkflowTests(unittest.TestCase, ConformsToISecurityWorkflow):

    def _getTargetClass(self):
        from {{package}}.security import ProfileWorkflow
        return ProfileWorkflow

    def _makeOne(self, context=None):
        if context is None:
            context = testing.DummyModel()
        return self._getTargetClass()(context)

    def _makeSite(self):
        site = testing.DummyModel()
        site['profiles'] = testing.DummyModel()
        site.users = DummyUsers(
            userid={'groups': ['group.community:foo:members',
                               'group.another']})
        profile = site['profiles']['userid'] = testing.DummyModel()
        profile.__acl__ = ['1']
        index = DummyIndex()
        site.catalog = {'path': index}
        return site, profile, index

    def _makeContext(self):
        site, profile, index = self._makeSite()
        context = site['testing'] = testing.DummyModel()
        context.creator = 'userid'
        context.docid = 1234
        return context

    def test_setInitialState_defaults(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        workflow.setInitialState()
        self.assertEqual(context.security_state, 'inherits')

    def test_setInitialState_sharing_False(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        workflow.setInitialState(sharing='false')
        self.assertEqual(context.security_state, 'inherits')

    def test_setInitialState_sharing_True(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        workflow.setInitialState(sharing='true')
        self.assertEqual(context.security_state, 'inherits')

    def test_execute_inherits_to_inherits(self):
        context = self._makeContext()
        workflow = self._makeOne(context)
        context.security_state = 'inherits'
        workflow.execute('inherits')
        self.assertEqual(context.security_state, 'inherits')

class Test_revise_profile_acl(unittest.TestCase):

    def _callFUT(self, event):
        from {{package}}.security import revise_profile_acl
        revise_profile_acl(event)

    def _makeSite(self):
        site = testing.DummyModel()
        site['profiles'] = testing.DummyModel()
        site.users = DummyUsers(
            userid={'groups': ['group.community:foo:members',
                               'group.another']})
        profile = site['profiles']['userid'] = testing.DummyModel()
        profile.__acl__ = ['1']
        profile.creator = 'userid'
        profile.docid = 1234
        index = DummyIndex()
        site.catalog = {'path': index}
        return site, profile, index

    def test_uninteresting_event(self):
        self._callFUT(object())

    def test_added_group_event(self):
        from zope.interface import implements
        from repoze.bfg.security import Allow
        from karl.models.interfaces import IUserAddedGroup
        from karl.security.policy import GUEST_PERMS
        from karl.security.policy import MEMBER_PERMS
        from karl.security.policy import NO_INHERIT
        site, profile, index = self._makeSite()
        class AddedGroup:
            implements(IUserAddedGroup)
            id = 'userid'
            login = 'userid'
            groups = ()

        event = AddedGroup()
        event.site = site

        self._callFUT(event)

        self.assertEqual(len(profile.__acl__), 3)
        self.assertEqual(profile.__acl__[0], (Allow, 'userid', MEMBER_PERMS))
        self.assertEqual(profile.__acl__[1],
                         (Allow, 'group.community:foo:members', GUEST_PERMS))
        self.assertEqual(profile.__acl__[2], NO_INHERIT)
        self.assertEqual(index.indexed, {1234: profile})

    def test_removed_group_event(self):
        from zope.interface import implements
        from repoze.bfg.security import Allow
        from karl.models.interfaces import IUserRemovedGroup
        from karl.security.policy import GUEST_PERMS
        from karl.security.policy import MEMBER_PERMS
        from karl.security.policy import NO_INHERIT
        site, profile, index = self._makeSite()
        class RemovedGroup:
            implements(IUserRemovedGroup)
            id = 'userid'
            login = 'userid'
            groups = ()

        event = RemovedGroup()
        event.site = site

        self._callFUT(event)

        self.assertEqual(len(profile.__acl__), 3)
        self.assertEqual(profile.__acl__[0], (Allow, 'userid', MEMBER_PERMS))
        self.assertEqual(profile.__acl__[1],
                         (Allow, 'group.community:foo:members', GUEST_PERMS))
        self.assertEqual(profile.__acl__[2], NO_INHERIT)
        self.assertEqual(index.indexed, {1234: profile})

class TestReindex(unittest.TestCase):
    def _callFUT(self, *arg, **kw):
        from {{package}}.security import _reindex
        return _reindex(*arg, **kw)

    def test_with_allowed_index_present(self):
        from repoze.folder.interfaces import IFolder
        from zope.interface import directlyProvides
        root = testing.DummyModel()
        root.catalog = {}
        root.docid = 0
        path = root.catalog['path'] = DummyIndex()
        allowed = root.catalog['allowed'] = DummyIndex()
        one = testing.DummyModel()
        one.docid = 1
        two = testing.DummyModel()
        two.docid = 2
        directlyProvides(root, IFolder)
        root['one'] = one
        root['two'] = two
        self._callFUT(root)
        self.failUnless(path.indexed.keys(), [0])
        self.assertEqual(sorted(allowed.indexed.keys()), [0,1,2])

    def test_with_allowed_index_missing(self):
        from repoze.folder.interfaces import IFolder
        from zope.interface import directlyProvides
        root = testing.DummyModel()
        root.catalog = {}
        root.docid = 0
        path = root.catalog['path'] = DummyIndex()
        one = testing.DummyModel()
        one.docid = 1
        two = testing.DummyModel()
        two.docid = 2
        directlyProvides(root, IFolder)
        root['one'] = one
        root['two'] = two
        self._callFUT(root)
        self.failUnless(path.indexed.keys(), [0])

class TestPostorder(unittest.TestCase):
    def _callFUT(self, node):
        from {{package}}.security import postorder
        return postorder(node)

    def test_None_node(self):
        result = list(self._callFUT(None))
        self.assertEqual(result, [None])

    def test_IFolder_node_no_children(self):
        from repoze.folder.interfaces import IFolder
        from zope.interface import directlyProvides
        model = testing.DummyModel()
        directlyProvides(model, IFolder)
        result = list(self._callFUT(model))
        self.assertEqual(result, [model])

    def test_IFolder_node_nonfolder_children(self):
        from repoze.folder.interfaces import IFolder
        from zope.interface import directlyProvides
        model = testing.DummyModel()
        one = testing.DummyModel()
        two = testing.DummyModel()
        model['one'] = one
        model['two'] = two
        directlyProvides(model, IFolder)
        result = list(self._callFUT(model))
        self.assertEqual(result, [two, one, model])

    def test_IFolder_node_folder_children(self):
        from repoze.folder.interfaces import IFolder
        from zope.interface import directlyProvides
        L = [] # "deactivated" list
        model = testing.DummyModel(_p_deactivate=lambda *x: L.append('model'))
        one = testing.DummyModel(_p_deactivate=lambda *x: L.append('one'))
        two = testing.DummyModel(_p_deactivate=lambda *x: L.append('two'))
        self.assertEqual(L, [])
        directlyProvides(two, IFolder)
        model['one'] = one
        model['two'] = two
        three = testing.DummyModel(_p_deactivate=lambda *x: L.append('three'))
        four = testing.DummyModel()
        two['three'] = three
        two['four'] = four
        directlyProvides(model, IFolder)
        result = list(self._callFUT(model))
        self.assertEqual(result, [four, three, two, one, model])
        self.assertEqual(L, ['three', 'two', 'one', 'model'])

class DummyCatalog:
    def reindex_doc(self, docid, obj):
        assert 0, "don't go here"

class DummyIndex:
    def __init__(self):
        self.indexed = {}
    def reindex_doc(self, docid, obj):
        self.indexed[docid] = obj

class DummyUsers:
    def __init__(self, **mapping):
        self.mapping = mapping

    def get_by_id(self, id):
        return self.mapping[id]
